#-----------------------------------------面试题1---------------------------------------------

#存在内存中的是对象  变量可以理解为内存中对象的引用 类型是属于对象的
#对象包括  (immutable)不可更改对象:strings  nnumers tuples   (mutable)可更改的对象:list dict
#而变量名就像是对象的引用，传递的时候就是复制了一个引用

# Case1

# a = 2      #immuable numbers
# def fun(a):  #引用复制之后虽然在括号里是2 a=1  相当于这个引用指向了内存中1这个对象
#     a=1
# fun(a)
# print(a)

# a=[]         #muable numbers
# def fun(a):  #因为是可变的所以还是指向当前对象
#     a.append(1)
# fun(a)
# print(a)


# Case2:python中的元类
# 1>
# 相对于类，类可以创建实例对象，相对于元类，类就是对象，元类创建类
# self对于类创建的对象，而cls是类本身
# @classmethod 修饰地方法是类方法  @staticmethod 修饰的是静态方法，类中无修饰器的是实例方法

# 2>
# 类中的变量有类变量和实例变量  类变量使用类进行调用的，实例变量是对象进行调用的
# class Foo():
#     name='1'  #immuable 不可更改的类变量
# f1 = Foo()
# print(f1.name)  #现在是f1.name 对应是类变量
# f1.name='2'     #但是经过更改之后f1.name就是实例变量  因为现在的f1.name这个变量指向内存中'2'这个对象了
# print(f1.name,Foo.name)

# 3>pyton自省
# type()  #用来返回对应对象的类型
    # print(type(1))
# dir() #dir()函数不带参数时，返回当前范围内的变量(包括内建变量)、方法和定义的类型列表；带参数时，返回参数的属性、方法列表
    #不带参数
    # ll = list()
    # a=1
    # def ff():
    #     pass
    # ret = dir()
    # print(ret)

    #带参数
    # ret = dir('s')  #带参数时，返回参数的属性、方法列表
    # print(ret)
#getattr(object, name)  获取对象object的属性或者方法，如果存在打印出来，如果不存在，打印出默认值，默认值可选。
# re = getattr('asd','isdigit')
# # print(re)
#hasattr(object, name)判断一个对象里面是否有name属性或者name方法，返回True 或是 False
    # print(hasattr('as','split'))
#setattr(object,name,values)  给对象的属性赋值，若属性不存在，先创建再赋值。

#getattr 和  seattr一起调用的方法，给某个对象设置默认值
# class test():
#     name='1'  #对应的是和对象存储的位置相同
# t = test()
# print(t.name)
# ret = getattr(t,'name',setattr(t,'name','cyl'))  #getattr(object,name,default) #没有name属性的时候就返回后边的default默认值
# print(ret)

#isinstance(object,str)  #判断某个对象是不是某种类型，返回True 或者False
    # ret = isinstance('ad',str)
    # print(ret)


#Case3: 字典推导式  字典中键可以是 int float str tuple 可以hash的对象
#       因为字典的存储是按照 键 的hash值对应hash表存储的所以for遍历的时候是无序的
#       可以用ccollections.OrderedDict可以按照输入的顺序存储
# s=[(1,2),(3,4)]
# d = {key:value for (key,value) in s}
#
# for item in d.keys():
#     print(type(item))

#类中的内部变量 (用import object 之后可以调用单下划线开头的变量和方法 而用from object import *就不能调用)
# _a   单下划线开头的是内部变量
# __a  双下划线开头的但不是双下划线结尾的是一般默认为私有变量
# __a__ 双下划线开头的双下划线结尾的是一般默认为内建变量
# class Foo():
#     __a=1  #因为__双下划线是私有变量所以在外部不能访问
# f = Foo()
# print(f.__a)

#字符串:%
# name = [1,2,3]
# print('%s'%name)
# 因为元组a=(1,2,3)是有括号的print('%s'%元组a)  %元组a就相当于%(1,2,3)而%(1,2,3)就相当于对应多个元素，
# 所以用%(元组a,)  也就是%((1,2,3),)  此时的元组就相当于是一个元素了而列表不是括号就可以%列表q
# name = (1,2,3)
# print('%s'%(name,))

#generator  and  iterator
#iterator :These iterables are handy because you can read them as much as you wish, but you store all the values in
            # memory and this is not always what you want when you have a lot of values.
# generator: Generators are iterators, a kind of iterable you can only iterate over once.
             #Generators do not store all the values in memory, they generate the values on the fly:


# *args  and **kwargs
# *args是可以接收多个参数
# **kwargs是可以接收字典
# def pr(*args):
#     for co,th in enumerate(args):
#         print('{0},{1}'.format(co,th))
# pr(1,2)

# def pr1(**kwargs):
#     for co,th in kwargs.items():
#         print(co,th)
# pr1(c='a',b='b')
# arg=(1,2,3)#[1,2,3]
# arg1 = {'a':1, 'e':2,'c':3, 'd':5}  #{'a':1, 'b':2,'c':3, 'd':5}
# # for i in arg1:
# # print(*arg)  #元组和列表可以直接解包
#
# def print_1(**a):
#     print(a)   #print只支持*args，不支持**kwargs
# print_1(**arg1)  #只能解包到第一层就是  key这一层   对于字典  *arg1  只能解包这一层， **arg1 能解开为 'a'=1,'b'=2...
#当这个解包的时候函数是按照  **a接收时，就会使字典的格式
# arg1 = {'a':1, 'b':2, 'c':3, 'd':4} #{'a':1, 'w':2,'e':3, 's':5}  #卧槽，当key是有顺序的时候  才可以解包为两层包就是解包出valu

# def myfun(a,b,c,d):
#     print(a+b+c+d)
# # mykw = {'a':1, 'b':2, 'c':3, 'd':4}
# myfun(**arg1)

# 12.鸭子类型
# “当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。”
# 我们并不关心对象是什么类型，到底是不是鸭子，只关心行为。
# 比如在python中，有很多file-like的东西，比如StringIO,GzipFile,socket。它们有很多相同的方法，我们把它们当作文件使用。
# 又比如list.extend()方法中,我们并不关心它的参数是不是list,只要它是可迭代的,所以它的参数可以是list/tuple/dict/字符串/生成器等.
# 鸭子类型在动态语言中经常使用，非常灵活，使得python不想java那样专门去弄一大堆的设计模式。


# 13.函数重载   因为python中变量可以接受任何变量类型，且个数也可以用*args接收，所以就没有重载
# 函数重载主要是为了解决两个问题。
# 1.可变参数类型。
# 2.可变参数个数。
# 另外，一个基本的设计原则是，仅仅当两个函数除了参数类型和参数个数不同以外，其功能是完全相同的，此时才使用函数重载，
# 如果两个函数的功能其实不同，那么不应当使用重载，而应当使用一个名字不同的函数。


# __str__ __all__
# class Foo():
#     def __init__(self):
#         self.a=1
#     def __str__(self):
#         self.a=2
#         print('__str__')
#         return '__str__'
#     def __call__(self, *args, **kwargs):
#         print('__call__')
#         return '__call__'
#
# f = Foo()  #自动调用__call__()方法
# f()
# print(f)   #自动调用 __str__
# print(f.a)

# 15.__new__和__init__的区别
#
# 这个__new__确实很少见到,先做了解吧.
# 1.__new__是一个静态方法,而__init__是一个实例方法.
# 2.__new__方法会返回一个创建的实例,而__init__什么都不返回.
# 3.只有在__new__返回一个cls的实例时后面的__init__才能被调用.
# 4.当创建一个新实例时调用__new__,初始化一个实例时用__init__.
# ps: __metaclass__是创建类时起作用.所以我们可以分别使用__metaclass__,__new__和__init__来分别在类创建,
# 实例创建和实例初始化的时候做一些小手脚.


# 16 单例模式
# 法一
# 在一个文件中 创建一个类的对象，在需要使用的时候可以从那个文件中导入创建的独对象

# class Foo(object):
#     __instance = None
#     def __new__(cls, *args, **kwargs):
#         if not cls.__instance:
#             cls.__instance = super(Foo, cls).__new__(cls,*args,**kwargs)
#         return cls.__instance
#     def __init__(self):
#         self.na='cyl'
#
# if __name__ == '__main__':
#     f = Foo()
#     f1 = Foo()
    # print(f.name)

#第二种单例模式


# 1.使用__new__方法
# class Singleton(object):
#     def __new__(cls, *args, **kw):
#         if not hasattr(cls, '_instance'):
#             orig = super(Singleton, cls)
#             cls._instance = orig.__new__(cls, *args, **kw)
#         return cls._instance
#
# class MyClass(Singleton):
#     a = 1
#
# # 2.创建实例时把所有实例的__dict__指向同一个字典,这样它们具有相同的属性和方法。
# class Foo(object):
#     _state={}
#     def __new__(cls, *args, **kwargs):
#         ob = super(Foo,cls).__new__(cls,*args,**kwargs)
#         ob.__dict__ = cls._state
#         return ob
# class myclass2(Foo):
#     a=1
#
# # 3装饰器版本
# def singleton(cls,*args,**kwargs):
#     instance = {}
#     def getinstance():
#         if cls not in instance:
#             instance[cls]=cls(*args,**kwargs)
#         return instance[cls]
#     return getinstance
#
# @singleton
# class myclass():
#     pass

# 4.文件导入方法
# class My_singleton():
#     def Foo(self):
#         pass
# my_singleton = My_singleton()
# from 文件名 import my_singleton
# my_singleton.foo()


# 17.Python中的作用域
# Python 中，一个变量的作用域总是由在代码中被赋值的地方所决定的。
# 当 Python 遇到一个变量的话他会按照这样的顺序进行搜索：
# 本地作用域（Local）→当前作用域被嵌入的本地作用域（Enclosing locals）
# →全局/模块作用域（Global）→内置作用域（Built-in）


# 18.GIL线程全局锁
# 线程全局锁(Global Interpreter Lock),即Python为了保证线程安全而采取的独立线程运行的限制,说白了就是一个核只能在同一时间运行一个线程.
# 解决办法就是多进程和下面的协程(协程也只是单CPU,但是能减小切换代价提升性能).
#
# 19.协程
# 简单点说协程是进程和线程的升级版,进程和线程都面临着内核态和用户态的切换问题而耗费许多切换时间,而协程就是用户自己控制切换的时机,不再需要陷入系统的内核态.
# Python里最常见的yield就是协程的思想!可以查看第九个问题.

# 20.闭包
# 闭包(closure)是函数式编程的重要的语法结构。闭包也是一种组织代码的结构，它同样提高了代码的可重复使用性。
# 当一个内嵌函数引用其外部作作用域的变量,我们就会得到一个闭包. 总结一下,创建一个闭包必须满足以下几点:
# 1.必须有一个内嵌函数
# 2.内嵌函数必须引用外部函数中的变量
# 3.外部函数的返回值必须是内嵌函数
# 感觉闭包还是有难度的,几句话是说不明白的,还是查查相关资料.
# 重点是函数运行后并不会被撤销,就像16题的instance字典一样,当函数运行完后,instance并不被销毁,而是继续留在内存空间里.这个功能类似类里的类变量,只不过迁移到了函数上.
# 闭包就像个空心球一样,你知道外面和里面,但你不知道中间是什么样.


#21filter 函数的功能相当于过滤器。调用一个布尔函数bool_func来迭代遍历每个seq中的元素；返回一个使bool_seq返回值为true的元素的序列。
# a = [1,2,3,4,5,6,7]
# b = filter(lambda x: x>5,a)  #把a中的每个元素传递到lambda函数中符合条件的加入到b列表
# print(b)
#
# #map函数是对一个序列的每个项执行函数
# a = map(lambda x:x*2,[1,2,3])  #对每一项进行乘2
# print(a)

#reduce函数是对一个徐磊的每个项迭代调用函数，下边是求3的结成
# from functools import reduce
# # reduce()还可以接收第3个可选参数，作为计算的初始值。如果把初始值设为100，计算：
# # reduce(f, [1, 3, 5, 7, 9], 100)
# a = reduce(lambda x,y:x*y,range(1,4))
# print(a)

#python中的拷贝copy() 为浅拷贝  deepcopy()为深拷贝

import copy
a = [1,2,3,4,['a','b']]  #原始对象
# b = a #这样是是传递的对象的引用
# b[0]=10
# print(a)
# c= copy.copy(a) #对象的浅拷贝，就是只拷贝列表的第一层，第二层还是指向一个对象
# c[0]=10  #证明了浅拷贝第一层是相当于复制了一份给c，而不仅仅是传递引用
# print(a)
# c[4][0]='c' #从这里可以看出第二层a和c还是指向的同一个地址
# print(a)
# d = copy.deepcopy(a)#对象拷贝，深拷贝,会把内层的也复制一份给d
# d[4][0]='e'
# print(a)

# 23.read readline readlines
# read  读取整个文件
# readline 读取下一行，使用生成器方法
# readlines 读取一个文件到一个迭代器供我们遍历


# 24.python语言解释
# 下边是一些关键点
# 1>python是一种解释性语言,也就是是说，与C语言和c的衍生语言
# 不同的是python代码不需要编译，其他解释性语言还包括php，ruby，python
# 是动态性语言，指的是在声明变量的时候，不需要说明变量的类型可以
# 直接赋值
#
# python是非常适合面向对象的编程，因为他通过支持通过组合
# (commposition)与继承(inheritance)的方式定义类(class)
# python中没有访问说明符(public，private)，大家都是成年人了
#
# 在python语言中，函数是第一类对象，这指的是他们可以被指定变量
# ，函数接你那个返回函数类型，也可以接受函数作为输入，类(class)
# 也是第一类对象
#
# python代码编写快，但是运行的速度比较慢，好在python加入了基于
# C语言的编写的拓展，因此我们能够优化代码，消除瓶颈，numpy就是
# 这么做的，运行速度很快，因为很多算术运算不是通过python实现的
#
# python用途非常的广泛--网络应用，自动化，科学建模，大数据的应用
# 等等，可以帮助其他语言改善运行状况，是一种叫胶水语言
#
# python不太在乎底层代码的实现，因此程序员可以更专注于算法和数据结构的
# 设计


# 25:阅读下边的a0到a6输出结果

# zip是把列表 元组 字典 可迭代对象转化成zip(zip中是元组存储) *zip是zip的相反过程
a0 = dict(zip(('a','b','c','d'),(1,2,3,4)))
# # print(type(a0))  #<class 'zip'>
# print(a0)

# a1 = range(10)
# print(type(a1))# [1,2,] 在python2种是list python3中是range

s = [0,1,2,3,4]
# a2 = [i for i in s if i in s]
# print (a2)

# a3 = [a0[s] for s in a0]   #python2中的dict是dictpython3中的dict默认是是OrderedDice
# print(a3)    #for s in a0 这个for循环是在a0种key

# a4 = [i for i in s if i in s]
# print(a4)

# a5 = {i:i*i for i in s}
# print(a5)

# a6 = [[i,i*i] for i in s]
# print(a6)


# 26.对于try except   当引发异常的时候，则执行过程会调到except语句
# 对于每个except分支顺序尝试执行，如果匹配就执行相应的语句，如果都不匹配则
# 异常就会跳到下一个调用本代码的最高层try代码中
# try下的语句执行正常就会执行else代码，否者就不执行else代码
# 如果存在finally语句，则就最后总会执行

# 27.如何用python来进行查询和替换一个文本字符串
# 答:可以使用re模块中的sub()函数来进行查询和替换格式
# sub(replcement,string[,count=1])  #count是可选对象表示最多偷换多少个字符串
# 使用re的一般步骤是先使用re.compile()函数，将正则表达式的字符串形式编译为Pattern实例，然后使用Pattern实例处理文本并获得匹配结果（一个Match实例），最后使用Match实例获得信息，进行其他的操作。

import re
# p = re.compile('blue|white|red')
# print(p.sub('color','blue  and white and red',count=1))
# subn()方法执行的效果跟sub()一样，不过它会返回一个二维数组，包括替换后的新的字符串和总共替换的数量

# 28用Python匹配HTML tag的时候，<.*>和<.*?>有什么区别？
# 答：术语叫贪婪匹配( <.*> )和非贪婪匹配(<.*?> )
# 例如:        .代表的是匹配一个字符  *代表的是匹配前边的字符0到n次
#              ?代表的是匹配钱一个字符0或1次
# test
# <.*> :
# test
# <.*?> :
# 后边多一个？表示懒惰模式。
# 必须跟在*或者+后边用
# 如：<img src="test.jpg" width="60px" height="80px"/>
# 如果用正则匹配src中内容非懒惰模式匹配
# src=".*"
# 匹配结果是：src="test.jpg" width="60px" height="80px"
# 意思是从="往后匹配，直到最后一个"匹配结束
# 懒惰模式正则：
# src=".*?"
# 结果：src="test.jpg"
# 因为匹配到第一个"就结束了一次匹配。不会继续向后匹配。因为他懒惰嘛。

# 29.有没有一个工具可以帮助查找python的bug和进行静态的代码分析？
# 答：PyChecker是一个python代码的静态分析工具，它可以帮助查找python代码的bug, 会对代码的复杂度和格式提出警告，
# Pylint是另外一个工具可以进行codingstandard检查。

# 30.Python和多线程（multi-threading）。这是个好主意码？列举一些让Python代码以并行方式运行的方法。
# Python并不支持真正意义上的多线程。Python中提供了多线程包，但是如果你想通过多线程提高代码的速度，使用多线程包并不是个好主意。Python中有一个被称为Global Interpreter Lock（GIL）的东西，它会确保任何时候你的多个线程中，只有一个被执行。线程的执行速度非常之快，会让你误以为线程是并行执行的，但是实际上都是轮流执行。经过GIL这一道关卡处理，会增加执行的开销。这意味着，如果你想提高代码的运行速度，使用threading包并不是一个很好的方法。
# 不过还是有很多理由促使我们使用threading包的。如果你想同时执行一些任务，而且不考虑效率问题，那么使用这个包是完全没问题的，而且也很方便。但是大部分情况下，并不是这么一回事，你会希望把多线程的部分外包给操作系统完成（通过开启多个进程），或者是某些调用你的Python代码的外部程序（例如Spark或Hadoop），又或者是你的Python代码调用的其他代码（例如，你可以在Python中调用C函数，用于处理开销较大的多线程工作）。
# 为什么提这个问题
# 因为GIL就是个混账东西（A-hole）。很多人花费大量的时间，试图寻找自己多线程代码中的瓶颈，直到他们明白GIL的存在。


# GIL解释：
# 一个进程 一个GIL CPU的核数
# ​ GIL 锁，全局解释器锁，作用就是，限制多线程同时执行，保证同一时间内只有一个线程在执行。
# ​ 线程非独立的，所以同一进程里线程是数据共享，当各个线程访问数据资源时会出现竞状态，即数据可能会同时被多个线程占用，造成数据混乱，这就是线程的不安全。
# ​ 所以引进了互斥（chi）锁，确保某段关键代码、共享数据只能由一个线程从头到尾完整地执行，但这个有个致命问题，死锁。
# ​ 死锁：若干子线程在系统资源竞争时，都在等待对方对某部分资源解除占用状态，结果哦谁也不愿意先解锁，互相等着，程序无法执行下去，这就是死锁。
# 知识扩展
# GIL 由于历史原因，龟叔在python中引进了GIL，保证每一个进程任何时候只有一个线程来执行，获取锁并获取资源，避免了多线程并发执行，保证了线程的安全。
# 现在对GIL 有两种声音，一种时接受GIL， 一种是不接受GIL，从python中移除
# 一接收GIL，自从python出现后，后面太多的模块都使用了python的GIL来编写，一旦去掉GIL ，这些模块都要重写，代价太大
# 二去掉GIL，去掉GIL 才能发挥多核处理器的优势，可以加快多线程程序的执行，实现真正的多线程
# 解决方案
# 1、换解释器 GIL 只有cpython有 可以换 jpython
# 2、换多进程 少用线程
# 3、用C语言扩展



#-----------------------------------------面试题2---------------------------------------------

# 单例模式1.
# way1:
# class foo():
#     _instance = None #类属性
#     def __new__(cls, *args, **kwargs):
#         if cls._instance is None:
#             cls._instance = super(foo,cls).__new__(cls,*args,**kwargs)
#         return cls._instance
# f = foo()
# f1= foo()
# print(id(f),id(f1))

# way2:由于装饰器导致解释器发生了改变，在某些情况下比如测试会导致问题，python通过functools.wrap解决这个问题
# 函数使用装饰器时,函数的函数名即 __name__已经被装饰器改变.
# 一般定义装饰器的话可以不用考虑这点,但是如果多个函数被两个装饰器装饰时就报错,因为两个函数名一样,第二个函数再去装饰的话就报错.
# from functools import wraps
# def singleton(cls):
#     isinstance = {}
#     @wraps(cls)
#     def getinstance(*args,**kwargs):
#         if cls not in isinstance:
#             isinstance[cls] = cls(*args,**kwargs)
#         return isinstance[cls]
#     return getinstance
#
# @singleton
# class foo(object):
#     a=1
# f = foo()
# f1 = foo()
# print(id(f),id(f1))

#3.使用模块
# 新建test
# class Myclass(object):
#     def foo(self):
#         print('myclass.foo')
# my_class_obj = Myclass()

#=========分割线=======
# from test import my_class_obj


# 斐波那契
# 1.迭代器实现，必须同时实现__iter__ 和 __next__
# class fib(object):
#     def __init__(self,n):
#         self.n = n #元素个数
#         self.a = 0
#         self.b = 1
#         self.index = 0 #记录位置的变量
#     #返回一个对象的引用返回迭代器对象
#     def __iter__(self):
#         return self
#     #计算
#     def __next__(self):
#         if self.index < self.n: #在范围内
#             ret = self.a
#             self.a, self.b = self.b, self.a+self.b
#             self.index +=1 #位置改变
#             return ret
#         else:
#             raise StopIteration
# obj = fib(100)
# tmp = iter(obj) #会把obj变成
# while True:
#     try:
#         v = next(tmp)
#         print('v = ',v)
#     except StopIteration:
#         break

# 2.生成器实现
# def create_fib(n):
#     a=0
#     b=1
#     for i in range(n):
#         yield a   #yield 后边的就是返回值  如果有传递的值就在前边接受
#         a,b = b,a+b
# gen = create_fib(5)
# # gen
# print(next(gen))

# v = gen.send(None)
# print(v)


#3乘法口诀
# def func():
#     row = 1
#     while row <= 9:
#         col = 1
#         while col<=row:
#             print('%d*%d=%d'%(col,row,(col*row)),end='\t')
#             col+=1
#         print()
#         row+=1
# func()


# 4.字符串去重
# str1 = 'qwerty'
# str2 = ''
# for a in str1:
#     if a not in str2:
#         str2 += a
# print(str2)


# 5.打印菱形
from functools import *
# num,cnt = 1,1
# import os
# while num <= 9:
#     j,k=1,1
#     while k <= abs(3 - cnt):
#         print(' ', end='')
#         k += 1
#     if num <=5:
#         while j <= num:
#             print('*',end='')
#             j += 1
#         print()
#         input('1>')
#     else:
#         while j <= 10-num:
#             print('*',end='')
#             j += 1
#         input('2>')
#
#     num += 2
#     cnt += 1
    # os.system('>')

#优化程序
# num, cnt = 1, 1
# while num <= 9:
#     j, k = 1, 1
#     print(' ' * (abs(3 - cnt)), end='')
#     if num <= 5:
#         print('*' * num)
#     else:
#         print('*' * (10 - num))
#     num += 2
#     cnt += 1

# import os
# # print(os.sep)
# # print(os.name)  #指示正在使用的工作平台window是nt linux是 posix
#
#
# # os 模块负责程序与操作系统的交互，提供了访问操作系统底层的接口;
# # sys 模块负责程序与python解释器的交互，提供了一系列的函数和变量，用于操控python的运行时环境;
#
# # OS 命令
# os.sep: 取代操作系统特定的路径分隔符
# os.name: 指示你正在使用的工作平台。比如对于Windows，它是
# 'nt'，而对于Linux / Unix用户，它是
# 'posix'。
# os.getcwd: 得到当前工作目录，即当前python脚本工作的目录路径。(绝对路径)
# os.getenv()
# 和os.putenv: 分别用来读取和设置环境变量
# os.listdir(): 返回指定目录下的所有文件和目录名
# os.remove(file): 删除一个文件
# os.chmod(file): 修改文件权限和时间戳
# os.mkdir(name): 创建目录
# os.rmdir(name): 删除目录
# os.removedirs（r“c：\python”）:删除多个目录
# os.system(): 运行shell命令
# os.exit(): 终止当前进程
# os.path.split(): 返回一个路径的目录名和文件名
# os.path.isfile()
# 和os.path.isdir()
# 分别检验给出的路径是一个目录还是文件
# os.path.existe(): 检验给出的路径是否真的存在
# os.listdir(dirname): 列出dirname下的目录和文件
# os.getcwd(): 获得当前工作目录
# os.chdir(dirname): 改变工作目录到dirname
# os.path.join(path, name): 连接目录与文件名或目录
# os.path.basename(path): 返回文件名
# os.path.dirname(path): 返回文件路径
#
# os.rename
# 对文件重命名
# os.remove
# 对文件删除
# os.mkdir
# 创建文件夹
# os.getcwd
# 获取当前目录
# os.chdir
# 更改默认目录
# os.listdir
# 获取目录列表
# os.rmdir
# 删除文件
# os.getcwd
# 指的是运行程序的目录(绝对路径)
# # sys 命令
# sys.argv
# 命令行参数List，第一个元素是程序本身路径
# sys.modules.keys()
# 返回所有已经导入的模块列表
# sys.exc_info()
# 获取当前正在处理的异常类, exc_type、exc_value、exc_traceback当前处理的异常详细信息
# sys.exit(n)
# 退出程序，正常退出时exit(0)
# sys.hexversion
# 获取Python解释程序的版本值，16
# 进制格式如：0x020403F0
# sys.version
# 获取Python解释程序的版本信息
# sys.maxint
# 最大的Int值
# sys.maxunicode
# 最大的Unicode值
# sys.modules
# 返回系统导入的模块字段，key是模块名，value是模块
# sys.path
# 返回模块的搜索路径，初始化时使用PYTHONPATH环境变量的值
# sys.platform
# 返回操作系统平台名称
# sys.stdout
# 标准输出
# sys.stdin
# 标准输入
# sys.stderr
# 错误输出
# sys.exc_clear()
# 用来清除当前线程所出现的当前的或最近的错误信息
# sys.exec_prefix
# 返回平台独立的python文件安装的位置
# sys.byteorder
# 本地字节规则的指示器，big - endian平台的值是
# 'big', little - endian平台的值是
# 'little'
# sys.copyright
# 记录python版权相关的东西
# sys.api_version
# 解释器的C的API版本
#
# # sys 实际用法
# 0.
# os.getcwd: 指的是当前目录, 绝对路径
# 1、sys.path[0]：主要模块的目录(绝对路径), 在模块运行的时候可以append方法
# 添加进去
# 2、sys.argv[0]：运行模块时, python后面的参数
# 3.
# __file__: 表示所在模块文件的路径，和系统找到该模块的方式有关，你是用绝对路径去加载该模块，那么__file__就为绝对模块文件路径，如果你给系统提供相对路径去加载该模块，那么改文件路径为相对路径
# 7.
# __file__
# 与argv[0]
# 路径问题
# # sys.argv[0]
# 获取主执行文件路径的最佳方法是用sys.argv[0]，它可能是一个相对路径，所以再取一下abspath是保险的做法
# dirname, filename = os.path.split(os.path.abspath(sys.argv[0]))
# ----> os.path.abspath(xxx)
# 返回xxx规范化的绝对路径。
#
# # __file__
# - 按相对路径. / test.py来执行，则打印得到的是相对路径，
# - 按绝对路径执行则得到的是绝对路径。
# - 而按用户目录来执行（~ / practice / test.py），则得到的也是绝对路径（~被展开）
# - 所以为了得到绝对路径，我们需要
# os.path.realpath(__file__)。
#
# 注意: 而在Python控制台下，直接使用print
# __file__是会导致
# name ‘__file__’ is not defined错误的，因为这时没有在任何一个脚本下执行，自然没有
# __file__的定义了

# linux命令：
# 0.
# man: 查看帮助信息
# 1.
# cd: 目录切换
# 2.
# ls: 查看目录信息
# ls - [l a d h R(递归)]
# 3.
# tree: 以树状形式查看指定目录的内容
# 4.
# 输出重定向命令： > > 输出重定向会覆盖原来的内容， >> 输出重定向则会追加到文件的尾部。
# 5.
# touch:
# 如果文件不存在, 创建新的空文件(只能是普通文件，不能是文件夹)
# 如果文件存在, 更新文件时间
# 6.
# ln: 命令主要用于创建链接文件(硬连接和软连接)
# 7.
# mkdir: 命令可以创建一个新的目录(不能新建普通文件)。参数 - p
# 可递归创建目录。
# 8.
# rm: 删除文件或目录
# 9.
# cp: 命令的功能是将给出的文件或目录复制到另一个文件或目录中
# 10.
# mv: 命令来移动文件或目录，也可以给文件或目录重命名
# 11.
# cat: 将文件内容一次性输出到终端(缺点：终端显示的内容有限，如果文件太长无法全部显示)
# 12.
# more: 命令将文件内容分页显示到终端
# 13.
# less: 命令将文件内容分页显示到终端，可以自由上下浏览
# 14.
# find: 命令在特定的目录下搜索符合条件的文件
# find + 路径 + -name +“文件名”
# 15.
# grep: 允许对文本文件进行模式查找。如果找到匹配模式， grep打印包含模式的所有行
# 16.
# 管道( |)：一个命令的输出可以通过管道做为另一个命令的输入
# 17.
# 压缩文件：zip - r
# 目标文件(可以不指定扩展名)
# 源文件
# 解压文件：unzip
# 压缩文件 - d
# 解压后目录文件
# 18.
# 文件权限管理: chmod
# u / g / o / a + / - /= rwx
# 文件
# user
# group
# other
# all / 增加权限
# 撤销权限
# 设定权限 / read可读取
# write可写入
# excute可执行
# 19.
# exit: 退出
# 20.
# ifconfig: 查看网卡信息
# 21.
# ping: 来检测网络是否正常
# 22.
# ps
# aux | grep
# xxx: 查看进程(A
# 显示所有的进程;
# a
# 不与terminal有关的所有进程;
# u
# 有效用户的相关进程;
# x
# 一般与a一起使用, 可列出较完整的信息 )
#
# 23.
# 查看内存使用:
# sudo
# atop: 终端环境的监控命令, 并且在搞负载的情况下进行了彩色标注
# free - h: 快速查看内存使用情况的方法
#
# 24.
# 指定端口
# lsof - i: 端口号查看某个端口是否被占用
# 25.
# kill / killall
# 26.
# vim
# 27.
# time
#
# open
# ~ /.ssh  # 打开秘钥的目录
# ls - al
# ~ /.ssh  # 显示所有的ssh文件
# cat
# ~ /.ssh / id_rsa.pub  # 复制公钥
# sudo
# find / -name
# ".gitconfig"
#
# # ls 显示文件（目录）信息
# 帮助信息：man
# ls
# ls - -help(有中文)
# 参数：
# -a
# 显示所有文件，包括以.开头的隐藏文件
# -l以长格式显示文件或子目录的详细信息
# -R
# 递归的显示指定目录中的各个子目录中的文件
# -S
# 以文件大小排序
# -s
# 给出每个目录项所用的块数
# -t
# 以文件的修改时间的先后顺序排序
# -d
# 如果参数是目录，只显示其名称而不显示其下的各文件，往往与1选项一起使用，已得到目录的详细信息
# -m
# 横向显示目录下的文件，文件名之间以逗号分隔。
# -h
# 将文件容量以较易读的方式(GB
# KB)列出来
#
# # linux中的&&和&，|和||
# - & 表示任务在后台执行，如要在后台运行redis - server, 则有
# redis - server &
# - & & 表示前一条命令执行成功时，才执行后一条命令 ，如
# echo
# "1" & & echo
# "2"
# - | 表示管道，上一条命令的输出，作为下一条命令参数，如
# echo
# "yes" | wc - l
# - | | 表示上一条命令执行失败后，才执行下一条命令，如
# cat
# nofile | | echo
# "fail"
#
# # 定时任务
# Linux
# 的
# Crontab
# 执行命令: sudo
# crontab - e
#
# # 线上服务可能因为种种原因导致挂掉怎么办
# Linux
# 下的后台进程管理利器
# supervisor
# 每次文件修改后在
# linux
# 执行: service
# supervisord
# restart

# git：
# git clone 克隆指定仓库
#
# git status 查看当前仓库状态
#
# git diff 比较版本的区别
#
# git log 查看 git 操作日志 ;  git reflog 可以查看所有分支的所有操作记录（包括commit和reset的操作），包括已经被删除的commit记录，git log 则不能察看已经删除了的commit记录
#
# git reset 回溯历史版本  ;git reset --hard 版本号   # 复制前面7位数字
# git add 将文件添加到暂存区
# git commit 将文件提交到服务器
# git checkout 切换到指定分支
# git rm 删除指定文件
#
# git add front_end_pc  # 添加子目录front_end_pc 到本地缓存里 , 把写的代码添加到本地缓存中
# git add .  # 添加本地目录下的所有代码 到本地缓存里面
# git status  # 查看状态, 这个习惯要养成
# git commit -m 'add front end files' # 提交到本地仓库里面 , -m:本次提交的描述信息
# git push  # 把本地仓库的代码推送到远程仓库 推送
# git push origin dev:dev  # 把本地仓库里的代码, 推送到远程仓库
# git branch # 查看分支
# git branch "分支名" # 创建分支
# git checkout "分支名" # 切换分支
# git checkout -b "分支名"  # 创建并切换到分支 :"分支名"
# git merge "分支名"  # 合并某分支到当前分支
# git branch -d "分支名"  # 删除分支
# git pull  # 下拉
# 可以使用前端node.js 提供的服务器live-server作为前端开发服务器使用。
# 安装node.js的版本控制工具nvm，在终端中执行

# 10.常见的状态码
# 1xx : 请求没完成,请求中
# 2xx : http 请求完成
# 3xx : 重定向
# 4XX : 客户端的请求有误
# 5xx : 服务器的响应错误
# 6xx 7xx : 开发者自定义的
# =====
# 200 服务器成功返回用户请求的数据
# 201 用户新建或修改数据成功
# 202 表示一个请求已经进入后台排队(异步任务)
# 204 用户删除数据成功
# 300 多选择 针对请求,服务器可执行多种操作
# 301 永久移动
# 302 临时移动
# 305 请求中应该使用代理
# 307 临时重定向
# 400 用户发出的请求有误,服务器没有进行新建或修改数据的操作
# 401 用户没有权限
# 403 服务器拒绝请求
# 404 服务器找不到请求的页面
# 406 无法使用请求的内容特性响应请求的网页
# 410 用户请求的资源被删除
# 500 服务器遇到存储,无法完成请求
# 501 服务器不具备完成请求的功能
# 502 错误网关
# 503 服务器不可用
# 504 网关超时
# 505 HTTP版本不受支持

# 11.python大文件的读取
# with open('test.py','r',encoding='utf-8') as f:
#     for line in f:
#         print(f)

#12 python2与python3的区别
# 先说主要区别(字符集)
# - 在python3中: 字符串是unicode编码后的字符串, str类型的, 二进制是bytes类型的, 编码使用的是encode, 解码使用的decode, 默认字符集是utf - 8
# Unicode: type(s) -> str
# 非Unicode: type(s) -> bytes
# 二进制
# - 在python2中:字符串也是Unicode编码后的字符串, 是Unicode类型的, 二进制是str类型的, 编码使用的是encode, 解码使用的decode, 默认字符集是ASCII码
# Unicode: type(s) -> unicode
# 非Unicode: type(s) -> str
# 二进制
#
# # Unicode字符集: 万国码, 占用两个字节, 一般程序内部使用,解决了各个国家编码不一致的请求，但是Unicode里每个字符都占用 3~4 个字节，导致文件过大。
# --> 于是
# utf - 8
# 诞生（可变长的Unicode），可以根据字符的种类变换长度，如一个字母占
# 1
# 个字节，一个汉字
# 3
# 个字节，可以降低文件的大小占用
#
# Python2
# 里默认代码文件头部编码声明是
# ascii，只能在python代码里写
# ascii
# 字符，如果有中文会报语法错误。所以需要手动声明：
# # coding:utf-8
#
# #
# # python 2
# 1) 在代码最上行写:  # -*- coding: utf8 -*-
# 2) 设置解释器编码
# uft - 8
# reload(sys)
# sys.setdefaultencoding('utf-8')
#
# 1).print
# py2：print语句，语句就意味着可以直接跟要打印的东西，如果后面接的是一个元组对象，直接打印
#
# py3：print函数，函数就以为这必须要加上括号才能调用，如果接元组对象，可以接收多个位置参数，并可以打印
#
# 如果希望在
# Python2
# 中
# 把
# print 当函数使用，那么可以导入
# future
# 模块
# 中的
# print_function
#
# 2).输入函数
# py2：input_raw()
#
# py3：input()
#
# 3).在使用super()
# 的不同
# py2：必须显示的在参数中写上基类
#
# py3：直接无参数调用即可
#
# 4).1 / 2
# 的结果
# py2：返回0
#
# py3：返回0
# .5，没有了int和long的区别
#
# 5).编码
# py2：默认编码ascii
#
# py3：默认编码utf - 8
#
# 而且为了在py2中使用中文，在头部引入coding声明，不推荐使用
#
# 6).字符串
# py2：unicode类型表示字符串序列，str类型表示字节序列
#
# py3:：str类型表示字符串序列，byte类型表示字节序列
#
# 7).True和False
# py2：True
# 和
# False
# 在
# Python2
# 中是两个全局变量，可以为其赋值或者进行别的操作，初始数值分别为1和0，虽然修改是违背了python设计的原则，但是确实可以更改
#
# py3：修正了这个变量，让True或False不可变
#
# 8).迭代器
# py2：当中许多返回列表的方法，如range, 字典对象的
# dict.keys()、dict.values()
# 方法, map、filter、zip；并且迭代器必须实现next方法
#
# py3：将返回列表的方法改为了返回迭代器对象，内置了__next__，不用特意去实现next
#
# 9).nonlocal
# py2：没有办法在嵌套函数中将变量声明为一个非局部变量，只能在函数中声明全局变量
#
# py3：nonlocal方法实现了，示例如下：
#
# 10).字符串
# 比较符合以下规则： "0" < "A" < "a", python3
# 中取消了这个


# 13.python中新式类和就是类
#1.类继承object
# 新式类都从object继承，经典类则不需要
# 新式类的MRD(基类搜索顺序)算法采用c3广度优先搜索而旧式类中则采用的深度优先搜索
# 新式类的相同父类只执行一次构造函数，经典类重复执行多次

# python2中默认都是经典类，除非显式的继承object才是新式类
# python3中默认的都是新式类，经典类被移除，不必显式的继承object

#继承类的搜索顺序
# 1）经典类多继承搜索顺序(深度优先):
# 先深入继承左侧查找，然后再反回深入右侧查找
# 2）新式类中是采用广度优先算法:c3算法，现在水平方向上查找，再向上查找


# 14:同步阻塞/异步阻塞
# 同步:多个任务之间有先后顺序执行，一个执行完下个才能执行。
# 异步:多个任务之间没有先后顺序，可以同时执行有时候一个任务可能要在必要的时候获取另一个同时执行的任务的结果，这个就叫回调!
# 阻塞:如果卡住了调用者，调用者不能继续往下执行，就是说调用者阻塞了。
# 非阻塞:如果不会卡住，可以继续执行，就是说非阻塞的。
#
# 同步异步相对于多任务而言，阻塞非阻塞相对于代码执行而言。

# 15.
# # 内存管理
# C语言的手工管理，Java的垃圾回收
# 以Python语言为例子，说明一门动态类型的、面向对象的语言的内存管理方式。
# - 内存地址;
# is用于判断两个引用所指的对象是否相同
# - 每个对象都有存有指向该对象的引用总数，即引用计数(reference
# count)
# - sys包中的getrefcount()，来查看某个对象的引用计数
#
# # 内存池机制
# 当创建大量消耗小内存的对象时，频繁调用new / malloc会导致大量的内存碎片，致使效率降低。内存池的概念就是预先在内存中申请一定数量的，大小相等的内存块留作备用，当有新的内存需求时，就先从内存池中分配内存给这个需求，不够了之后再申请新的内存。这样做最显著的优势就是能够减少内存碎片，提升效率
# python中的内存管理机制都有两套实现
# 1).一套是针对小对象，就是大小小于256bits时，pymalloc会在内存池中申请内存空间；
# 2).当大于256bits，则会直接执行
# new / malloc
# 的行为来申请新的内存空间。
#
# # 垃圾回收机制 GC
# 一: 引用计数
# 引用计数通过记录对象被引用的次数来管理对象。
# 对对象的引用都会使得引用计数加1，移除对对象的引用，引用计数则会减1，当引用计数减为0时，对象所占的内存就会被释放掉。
# 引用计数可以高效的管理对象的分配和释放, 但是有一个缺点，就是无法释放循环引用的对象
# 什么是循环引用: A和B相互引用而再没有外部引用A于B中的任何一个, 如果是使用引用计数法来管理这两对象的话，他们并不会被回收，它会一直驻留在内存中，就会造成了内存泄漏（内存空间在使用完毕后未释放）
# 总结: 只有容器对象才会出现循环引用
#
# 二: 标记清除
# 『标记清除（Mark—Sweep）』算法是一种基于追踪回收（tracing
# GC）技术实现的垃圾回收算法。它分为两个阶段：第一阶段是标记阶段，GC会把所有的『活动对象』打上标记，第二阶段是把那些没有标记的对象『非活动对象』进行回收.
#     对象之间通过引用（指针）连在一起，构成一个有向图，对象构成这个有向图的节点，而引用关系构成这个有向图的边。从根对象（root
# object）出发，沿着有向边遍历对象，可达的（reachable）对象标记为活动对象，不可达的对象就是要被清除的非活动对象。根对象就是全局变量、调用栈、寄存器
#                                                                              * 缺点 *: 清除非活动的对象前它必须顺序扫描整个堆内存，哪怕只剩下小部分活动对象也要扫描所有对象。
#
# 三: 分代回收
# 分代回收是一种以空间换时间的操作方式，Python将内存根据对象的存活时间划分为不同的集合，每个集合称为一个代，Python将内存分为了3“代”，分别为年轻代（第0代）、中年代（第1代）、老年代（第2代），
# 他们对应的是3个链表，它们的垃圾收集频率与对象的存活时间的增大而减小。新创建的对象都会分配在年轻代，年轻代链表的总数达到上限时，Python垃圾收集机制就会被触发，把那些可以被回收的对象回收掉，
# 而那些不会回收的对象就会被移到中年代去，依此类推，老年代中的对象是存活时间最久的对象，甚至是存活于整个系统的生命周期内。同时，分代回收是建立在标记清除技术基础之上。分代回收同样作为Python的辅助垃圾收集技术处理那些容器对象


# 16.变量的声明周期 和 小缓存池
# 变量的声明周期
# 1.) 析构方法
# __del__
# 2.) 当变量的引用为0的时候, 变量就会被回收
# 3.) 循环引用: A和B相互引用而再没有外部引用A于B中的任何一个, 如果是使用引用计数法来管理这两对象的话，他们并不会被回收，它会一直驻留在内存中，就会造成了内存泄漏(内存空间在使用完毕后未释放)
#
# # 小缓存池
# python
# 定义的数值缓存范围是 - 5
# ~ 257
# - 直接从缓存池中返回, 不需要申请内存, 如果超出就要申请内存
# - 在 - 5
# ~257
# 范围内, ip都一样

# 17.变量作用域及调用优先级
# 1.变量作用域
#
# L（local） 局部作用域
# E（Enclosing） 闭包函数外的函数中
# G（Global） 全局作用域
# B（Built-in） 内建作用域
# 2.遵循LEGB原则：
# 以 L –> E –> G –>B 的规则查找，即：在局部找不到，便会去局部外的局部找（例如闭包），再找不到就会去全局找，再者去内建中找

# x = int(2.9)  # 内建作用域
#
# g_count = 0  # 全局作用域
#
# def outer():
#     o_count = 1  # 闭包函数外的函数中
#     def inner():
#         i_count = 2  # 局部作用域
# 1).若内部作用域的想要修改外部作用域的变量，就要使用global关键字
# 2).nonlocal 关键字的使用方法和global关键字类似，修改嵌套作用域（enclosing 作用域，外层非全局作用域）中的变量
#
# def outer():
#     num = 10
#     def inner():
#         nonlocal num   # nonlocal关键字声明
#         num = 100
#         print(num)
#     inner()
#     print(num)
# outer()
#
# 运行结果为
# 100
# 100
# 闭包函数外的变量num值被修改


# 18.python解压zip文件  https://www.cnblogs.com/flyhigh1860/p/3884842.html
# zip 与tar类似，先读取多个文件名称，然后解压。例如以下：
#
# import zipfile, os
# def un_zip(file_name):
#     """unzip zip file"""
#     zip_file = zipfile.ZipFile(file_name)
#     if os.path.isdir(file_name + "_files"):
#         pass
#     else:
#         os.mkdir(file_name + "_files")
#     for names in zip_file.namelist():
#         zip_file.extract(names,file_name + "_files/")
#     zip_file.close()

# 19.设计模式(单例模式,工厂模式)
# 设计模式是经过总结优化的，对我们经藏碰到的一些编程问题可重用解决方案
# 为了解决面向对象系统中重要和重复的设计封装在一起的一种代码实现框架,可以使得代码更加易于扩展和调用
# 一.单例模式
# 1.保证一个类只有一个实例,并且提供一个访问该实例的全局访问点
# 适用场景：
# 1.需要生成唯一序列的环境
# 2.需要频繁实例化然后销毁的对象。
# 3.创建对象时耗时过多或者耗资源过多，但又经常用到的对象。
# 4.方便资源相互通信的环境
# 优点：
# 1.实现了对唯一实例访问的可控
# 2.对于一些需要频繁创建和销毁的对象来说可以提高系统的性能。
# 缺点：
# 1. 不适用于变化频繁的对象
# 2.滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为的单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出。
# 3.如果实例化的对象长时间不被利用，系统会认为该对象是垃圾而被回收，这可能会导致对象状态的丢失。

# 20.匿名函数 lambda
# lambda 函数是匿名函数;使用 lambda 函数能创建小型匿名函数。这种函数得名于省略了用 def 声明函数的标准步骤
# lambda 函数是一个可以接收任意多个参数(包括可选参数)并且返回单个表达式值的函数
# 格式: lambda 形参 : 返回值
# 一次性函数,以表达式的形式定义一个函数,只能做一些简单处理
# 作用:
# 1、lambda 函数比较轻便，即用即仍，很适合需要完成一项功能，但是此功能只在此一处使用， 连名字都很随意的情况下;
# 2、匿名函数，一般用来给 filter， map 这样的函数式编程服务;
# 3、作为回调函数，传递给某些应用，比如消息处理
# 4. 因为函数没有名字，不必担心函数名冲突
# def multipliers():
#     return [lambda x: i * x for i in range(4)]
#     print[m(2)
#     for m in multipliers()]
#     结果: [6, 6, 6, 6]
# Lambda函数能接收任何数量的参数但只能返回一个表达式的值
# 匿名函数不能直接调用print，因为lambda需要一个表达式
# sum = lambda arg1,arg2: arg1+arg2
# print(sum(10,20))

# 1）自定义排序规则
# print((lambda *args : [a **2 for a in args]) (*[1,2]))  #   #直接print的时候lamba后边的表达式 用括号括起来，不能是列表，元组可以用*把列表或元组中的元素解压出来
#2)函数作为参数传递


# 21.高阶函数: map()函数 reduce()函数 filter()函数 sorted()函数
from functools import reduce
# ret = reduce(lambda x,y: x+y,[1,2,3])
# ret = map(lambda x:x+1,[1,2,3]) #是对列表中的每一个元素传递给函数处理  后返会一个值
# ret = filter(lambda x:x<=2 ,[1,2,3]) #对列表中的元素进行过滤，符合条件的留下，不符合的就丢弃，python2返回一个列表，python3返回filter对象
# 4.sorted() 函数对所有可迭代的对象进行排序操作。
# sort与sorted的区别:
# sort是应用在list上的方法，sorted可以对所有可迭代对象进行排序
# list 的 sort 方法返回的是对已经存在的列表进行操作，而内建函数 sorted 方法返回的是一个新的 list，而不是在原来的基础上进行的操作。
# sorted(iterable[, cmp[, key[, reverse]]])
# 1).iterable -可迭代对象。
# 2).cmp -比较的函数，这个具有两个参数，参数的值都是从可迭代对象中取出，此函数必须遵守的规则为，大于则返回1，小于则返回-1，等于则返回0。
# 3).key -主要是用来进行比较的元素，只有一个参数，具体的函数的参数就是取自于可迭代对象中，指定可迭代对象中的一个元素来进行排序。
# 4).reverse -排序规则，reverse = True 降序 ， reverse = False 升序（默认）。
# print(list(ret))
# for表达式
# s = [x if x<=2 else -x for x in [1,2,3] ]


# 23.魔法方法
# __new__      创建实例(对象的构造器)
# __init__     初始化方法(对象的构造器)
# __del__      对象的销毁器,当对象在内存中被释放时，自动触发执行
# __str__      类的实例调用,自定义输出方法  必须是print(实例名) 才会调用 直接一个实例名字放在那里不会调用
# __repr__     机器可读的输出    这个不管是print(实例名)  还是实例名直接放在这，都会调用
# __call__     可调用对象的方法 允许你自己类的对象表现得像是函数,对象后面加括号，触发执行
# __repr__用于所有其他的环境中：用于交互模式下提示回应以及repr函数，如果没有使用__str__，会使用print和str。它通常应该返回一个编码字符串，可以用来重新创建对象，或者给开发者详细的显示。

# class Foo:
#     def __init__(self):
#         pass
#
#     def __call__(self, *args, **kwargs):
#         print('__call__')
# obj = Foo()  # 执行 __init__
# obj()  # 执行 __call__

# __enter__() 和 __exit__() 方法的对象都可称之为上下文管理器 with 关键字( contextmanager 装饰器 也可以实现)
# __doc__      类的描述信息
# __module__   表示当前操作的对象在哪个模块
# __class__    表示当前操作的对象的类是什么
# __dict__     类或对象中的所有属性，都可以使用print 输出对应的信息
# __getslice__、__setslice__、__delslice__   用于分片操作，如：列表
# __getitem__、__setitem__、__delitem__      用于索引操作，如字典。以上分别表示获取、设置、删除数据
# __import__   需要导入的模块的名字<字符串> 返回是导入的模块对象的引用
# __repr__用于所有其他的环境中：用于交互模式下提示回应以及repr函数，如果没有使用__str__，会使用print和str。它通常应该返回一个编码字符串，可以用来重新创建对象，或者给开发者详细的显示。
# 当我们想所有环境下都统一显示的话，可以重构__repr__方法；当我们想在不同环境下支持不同的显示，例如终端用户显示使用__str__，而程序员在开发期间则使用底层的__repr__来显示，实际上__str__只是覆盖了__repr__以得到更友好的用户显示。


# 23.GIL锁  全局解释器锁
# GIL:
# 全局解释器锁。每个线程在执行的过程都需要先获取GIL，保证同一时刻只有一个线程可以执行代码
# 在 Python 多线程下，每个线程的执行方式:
# 1、获取 GIL
# 2、执行代码直到 sleep 或者是 python 虚拟机将其挂起。
# 3、释放 GIL
#
# cpython解释器内部多线程使用的 互斥锁(使用多线程的时候才会出现GIL, 多进程则不会出现)
#
# 目的: 防止解释器内部的全局资源产生资源竞争问题
#
# 影响: 不能有效利用多核资源
#
# cpython多线程 实际上是并发执行的
#
# 什么时候会释放GIL锁?
#
# 超时自动释放,
# 使用计时器,tickets计数达到100释放GIL
# 线程被阻塞了,也会释放(recv 阻塞)
#
# 如何解决GIL 的影响= 如何才能使用多核
# 多进程
# 其它语言编写的代码(c语言)
# 换个其它解释器 pypy java
# 小知识点htop命令查询 linux系统资源占用情况
# GIL锁爬虫情况下: 多线程爬取比单线程性能有提升，因为遇到IO阻塞会自动释放GIL锁

# 24.浅拷贝和深拷贝
# 浅拷贝
# 浅拷贝是对于一个对象的顶层拷贝,照搬照抄
# 拷贝了引用，并没有拷贝内容
# 好处:节约内存空间,节约时间,提高效率
# 当给一个变量赋值时,其实就是将数据的引用复制了一份给另外一个变量=浅拷贝
# 分片表达式可以赋值一个序列 分片属于浅拷贝
# 列表 元组 字符串 可以分片操作, 字典因为是kv 不可以分片操作
# 列表是可变类型 后面新增了不会被b浅拷贝指向
# 元组 不可变类型,不会拷贝,只是变量地址的引用
# copy.copy对于可变类型，会进行浅拷贝,只会复制最顶层的那个列表
# copy.copy对于不可变类型，不会拷贝，仅仅是引用的指向(没有意义的)
# 深拷贝
# 深拷贝是对于一个对象所有层级的完全拷贝(递归)

# 25.私有化
# 使用私有化的意义
# 1.保护数据(增加代码复杂程度 防止用户意外修改)
# 2.增加访问控制权限(提供方法,间接访问  在类外不能直接访问
# 3.提高代码的规范性 减少出现错误的可能)
# xx    公有变量
# _xx   假的 口头的私有化,可以访问,需要单独导入才能使用
# __xx  无法在类外访问,不可以被子类访问(名字重整了所有访问不到 print(dir类名)查看类里面的所有属性),但是子类可以通过父类提供的方法间接访问, 需要单独导入才能使用
# __xx__  用户名字空间的魔法对象或熟悉
# xx_   用于避免与python关键字冲突

# 26.import 导入模块
# 输入sys.path ，就会列出一些目录，这些目录就是python回去找模块的路径
# -''表示当前路径
# -列表中的路径先后顺序，代表了python解释器在搜索模块的先后顺序
# 可以通过 sys.path.append('路径') 添加
#     .使用 sys.path.append('common/')  默认加在sys.path的最后
#     .使用 sys.path.insert(0,‘common/’)  后会将path目录加在最前面
# 当你导入一个模块时，Python解析器对模块位置的搜索顺序是：
# ①当前目录
# ②如果不在当前目录，Python则搜索PythonPath下的每个目录
# ③如果都找不到，Python会查看安装默认路径

#2.第二种方法是设置环境变量pythonpath

# 1.
# 模块只能导入一次
# - 模块就是一个对象
# - 模块只导入一次, 第二次只会直接使用以及导入成功的模块对象
# - 模块被导入后，import module不能重新导入模块，重新导入需用reload
# - 导入模块只会导入一次, 因此即使模块进行了修改, import也不会重新导入
# - python
# 3
# 重新导入模块方法:
# from imp import reload
#
# 2.
# 多模块开发时的注意点
# - 如果模块属性是可变类型,import from…import 都可以修改模块的属性
# - 如果模块属性是不可变类型,from…import 是不可能改变模块属性的,import 方式可以修改模块属性
# - 都会创建对象
# import 会将创建的 模块对象的引用 保存在本地作用域
# from-import 会将创建的模块对象的属性的引用保存在本地作用域
# - dir(模块名) 查看模块的所有属性
# 3.
# import过程分析
# - 模块的引用
# - 在搜索路径中找到, 如果其中没有就搜索, 所有import成功的模块都放在sys.modules中,
# import 导入和语句所在位置有关系
#
# - 执行模块代码, 创建模块对象和对应属性
# - 将创建好的模块名导入当前local名字空间
# - locals()查看本地名字空间当中所有的名字
# - globals()查看全局名字空间中所有的名字
#
# 4.
# from ... import 过程分析
# - 模块属性的引用
# - 只导入模块中的名字(变量 对象 类 函数)
# - 如果没有则创建空模块对象A执行模块代码并且在local中创建和前同名的对象
# - 如果模块对象中找到名字B将该名字放入locals空间中
# - sys.modules查找模块A

# 27.多继承和MRO顺序 super
# mro顺序作用:多继承中 能够保证所有的类按照该顺序进行初始化, 所有类只初始化一次
# super(super是一个类)的作用: 查找mro顺序中当前类的下一个类,super和父类没有关系super是一个类,在python3中不需要加参数,在python2中(分经典类 新式类 )

# 28.静态方法、类方法、实例方法
# 1.类属性，实例属性 它们定义和使用有所差别，而最本质的差别是内存中保存的位置不同
# 实例属性属于实例对象
# 类属性属于类
# 类属性在内存中只保存一份,所有实例对象共享的属性
# 实例属性在每个对象中都要保存一份,所有实例对象分别拥有自己的实例属性
# 实例对象也可以获取类属性,但是不能修改,二义性,python解释器会认为是需要绑定一个同名的实例属性
# 类对象可以访问类属性,但是类对象不能访问实例属性(因为实例属性在实例对象的空间里)

# 2.实例方法，静态方法和类方法
# 类属性、实例属性
# 它们在定义和使用中有所区别，而最本质的区别是内存中保存的位置不同，
# 实例属性属于实例对象
# 类属性属于类
# 类属性在内存中只保存一份,所有实例对象共享的属性
# 实例属性在每个对象中都要保存一份,所有实例对象分别拥有自己的实例属性
# 实例对象也可以获取类属性,但是不能修改,二义性,python解释器会认为是需要绑定一个同名的实例属性
# 类对象可以访问类属性,但是类对象不能访问实例属性(因为实例属性在实例对象的空间里)
# 实例方法、静态方法和类方法
# 在内存中都归属于类
# 区别在于调用方式不同:
# 1).实例方法：由对象调用；至少一个self参数；执行实例方法时，自动将调用该方法的对象赋值给self(区分哪个实例对象在调用实例方法)；对实例属性操作的封装 ; 实例对象的代码保存在类对象中,需要时再调用(节约空间)
# 2).类方法@classmethod：由类调用； 至少一个cls参数；执行类方法时，自动将调用该方法的类赋值给cls；对类属性的封装 , cls参数 表示类 A.get_count() —>get_count(A)
# 3).静态方法@staticmethod：不需要访问类属性,和实例属性所有不需要cls self 由类调用；无默认参数； 静态方法也可以修改类属性, (类名. 修改类属性) 将类功能和类相关的普通函数封装在一个类中 防止名字扩散
# 相同点：对于所有的方法而言，均属于类，所以 在内存中也只保存一份
# 不同点：方法调用者不同、调用方法时自动传入的参数不同。

# 29.property
# 主要目的:把函数封装 让用户使用属性方式操作数据,并且对数据的修改进行了有效的存储控制
#     - 定义时，在实例方法的基础上添加 @property 装饰器；并且仅有一个self参数
#     只需要加上@property就可以了，此时，@property本身又创建了另一个装饰器@score.setter，负责把一个setter方法变成属性赋值，于是，我们就拥有一个可控的属性操作：
# - 调用时,无需括号

# class Cat(object):
#     def __init__(self):
#         self.__age = 0
#     # 主要目的 是 让用户使用属性方式操作数据 并且 对数据的修改进行了有效的存储控制
#     @property
#     def age(self):
#         print("正在获取年龄")
#         return self.__age
#
#     @age.setter
#     def age(self,age):
#         # 存取控制 封装 使用稍微有些复杂
#         if age > 200 or age < 0:
#             print("设置的年龄有问题")
#         else:
#             self.__age = age
#
#     @age.deleter
#     def age(self):
#         print("删除age属性")
# c1 = Cat()
# # 普通对象.属性方式 特点:  使用简单 对数据的存取没有有效的控制
# print(c1.age)
# c1.age = 18888
# print(c1.age)
# del c1.age
# # c1.set_age(1888)  # 对象.方法 特点: 使用稍微复杂一点点 但是对数据进行了存取控制

# 30、python内置模块(标准库) / 内置函数 / 内置变量 / 第三方模块(第三方库)
# 内置模块(内置库), 存放在安装路径下
# 1).re模块 正则表达式:search、match、split、findall（finditer）、sub
# 2).os模块 （文件和目录）用于提供系统级别的操作(os.getcwd/os.makedir/os.rmdir/os.remove)
# 3).sys模块 用于提供对解释器相关的操作 sys.argv命令行参数,sys.version,sys.exit()
# 4).logging 用于便捷记录日志且线程安全的模块;debug info warning error critical
# 5).datetime 模块：时间相关的操作，时间有三种表示方式
# 6).random模块，随机数
# 7).json 和 pickle模块
#     -json, 用于字符串 和 python数据类型之间的额转换
#     -pickle 用于python特有的类型 和 python的数据类型间进行转换
# 8) hashlib模块，用于加密相关的操作,代替了md5模块和sha模块，主要提供SHA1 SHA224, SHA256, SHA384, SHA512 ，MD5 算法
# 9）threading:线程
#10）multiprocessing：进程
#11).socket
#12)types模块 给类和实例动态添加方法;from types import MethodType
    # 参数一: 要传递的函数
    # 参数二: 需要给的对象
# 13)md5;sha模块
# 14).copy 拷贝
# 第三方模块(库) 存放在安装路径下的 sit-packages里面
# requirements.txt 文件里列出项目要安装的包
#     1).pip install 模块名
#     2).源码安装:下载源码 解压 进入目录 执行python setup.py install
# image 模块: 操作图像的模块
# pymysql
# redis
# pymongo
# django
# flask
# gevent: 协程
# requests :
# pyGame: 用于编写游戏开发的跨平台应用程序框架
# ipython:
# pandas: 数据结构和数据分析工具的库
# Beautiful Soup: 用于解析 HTML 并从中提取信息。尤其适用于网络抓取
# Pillow: 影像库使你的 Python 解释器新增图像处理功能
# djangorestframework
#
# ====flask中用过的第三方库
# 1)Flask-WTF==0.14.2 自带csrf保护
# 2)flask-sqlalchemy
# 3)flask-mysqldb
# 4)redis
# 5)
# # 内置函数
# all() input() open() int() str() type() staticmethod() print() super() del()
# iter() tuple() len() range() list() float() format() max() min()  next() id()
#
# # 内置方法 = 魔法方法
# # 内置变量
# vars() 查看内置全局变量

# 31.python模块导入（内置模块，自定义模块，开源模块) 调用顺序
# https://www.cnblogs.com/liu-yao/p/5186322.html
# 模块时一个包含定义的函数和变量的文件,后缀名是.py
# import
# from 模块名 impory 函数1, 函数2
# 理解: 内置模块先调用, 重写内置模块的方法就是自定义模块, 自定义模块先调用

# 32.__future__
# 要在Python 2.7中引入3.x的除法规则，导入__future__的division：
#
# >>> from __future__ import division
# >>> print 10 / 3
# 3.3333333333333335



# 33.with 与上下文管理器
# 系统资源如文件、数据库连接、socket ,互斥锁 而言，应用程序打开这些资源并执行完业务逻辑之后，必须做的一件事就是要关闭（断开）该资源。
#
# 需求: 及时 自动释放打开的资源(文件 套接字 互斥锁)
#
# 目的: 简化用户开发流程 增强程序的功能
#
# 当try...finally中间的逻辑复杂,并带着各种嵌套的话,代码就不容易维护
# with 语句可以实现同样的功能
#
# 1.上下文管理器=用类来实现
# 任何实现了__ enter__() 和 __ exit__() 方法的对象都可称之为上下文管理器
# __enter__()方法会在with语句进入时调用,其返回值会赋值给as关键字后的变量
# __exit__() 方法在with语句退出后自动调用
# 2.contextmanager装饰器 和 yield(生成器)来实现
# [context_expression创建上下文管理器context_manager]
# @contextlib.contextmanager
# 通过 yield 将函数分割成两部分:
# yield 之前的语句在 __enter__() 方法中执行，
# yield 之后的语句在__exit__()方法中执行
# yield 后面的值是函数的返回值。就是with语句块中的代码。如果yield后面带参数的话，我们就可以用as关键字赋值给后面的变量
# 注意: @contextlib.contextmanager”不像之前介绍的__exit__()方法，遇到异常也会执行。也就是with语句块抛出异常的话，yield后面的代码将不会被执行。所以，必要时你需要对yield语句使用”try-finally”
# 上下文管理器的理解 : 上下文管理器的任务是 —— 代码块执行前准备，代码块执行后收拾
# contextmanager最大的好处就是可以将不是上下文处理器的类变成一个类似上下文处理的方式来解决问题。
# with语法格式 :with context_expression [as target(s)]:
# 这里context_expression返回的是一个上下文管理器对象.这个对象已经满足了上下文协议,也就是说这个对象已经有了__exit__()与__enter__()方法,其中如果使用了as,那么将会将__enter__()方法返回的值赋值给target(s)


# 34.闭包,装饰器 (语法糖)
# 闭包
# 1.)优点:闭包提高代码可复用性,减少代码的可移植性
# 2.)缺点:闭包引用了外部函数的局部变量，则外部函数的局部变量没有及时释放，消耗内存
# 3.)概念:在函数内部再定义一个函数，并且这个函数用到了外边函数的变量，那么将这个函数以及用到的一些变量称之为闭包,并返回
# 闭包中是不能修改外部作用域的局部变量的
# 4.)闭包的三个特点
# 函数的嵌套定义
# 外层函数返回了内层函数的引用 return
# 在内存函数中可以使用外层函数提供的变量-自由变量 环境变量

# 装饰器
# 引入日志
# 函数执行时间统计 (import time)
# 执行函数前预备处理
# 执行函数后清理功能
# 权限校验等场景
# 缓存 (data = list[] 把数据存在里面)
# 代码要遵循开放封闭原则:对代码修改时关闭 对代码功能扩展是开放的
# 1.装饰器的目的:在不修改函数代码的情况下,对函数功能进行扩展
# 2.装饰器函数特点: 满足闭包的特点,函数参数只有一个就是被装饰的函数的引用
#
# 35.from functools import wraps
# functools.wraps :还原函数的名字
# 由于装饰器的加入导致解释器认为函数本身发生了改变，在某些情况下(比如测试时)会导致一些问题。Python 通过 functool.wraps 为我们解决了这个问题

# 36.虚拟环境
# 1).虚拟环境就是借助虚拟机docker来把一部分内容独立出来，我们把这部分独立出来的东西称作“容器”
# 2).各个容器之间互相隔离，互不影响
# 3).在实际项目开发中，我们通常会根据自己的需求去下载各种相应的框架库，如Scrapy、Beautiful Soup等，但是可能每个项目使用的框架库并不一样，或使用框架的版本不一样，这样需要我们根据需求不断的更新或卸载相应的库。直接对我们的Python环境操作会让我们的开发环境和项目造成很多不必要的麻烦，管理也相当混乱
# 4).pip3 install virtualenv
# 启动虚拟环境: workon 或者 source active

# 37.上下文的理解
# 上下文：已经处理过的数据叫上文，正在处理的数据叫正文，准备要处理的数据叫下文。上下文是程序相关的数据。
# 1.) with 语法格式
# __exit__()与__enter__()方法
#
# 通过context_expression创建上下文管理器context_manager

# 38.列表推导式
# a = [x for x in range(3,19,2)]
# a = [x for x in range(3,10) if x%2]
# a = [(x,y) for x in range(5) for y in range(5)]

# 39.列表去重set
# # set list tuple 之间可以相互转换
# # set字典->list列表->tuple元组->list列表
# In [1]: b = [1,2,3,12,3,1,3]
# In [2]: c = set(b)
# In [3]: type(c)
# Out[3]: set
# In [4]: c
# Out[4]: {1, 2, 3, 12} # 字典
# In [5]: d = list(c)
# In [6]: d
# Out[6]: [1, 2, 3, 12]
# In [7]: e = tuple(d)
# In [8]: e
# Out[8]: (1, 2, 3, 12)
# In [9]: f = list(e)
# In [10]: f
# Out[10]: [1, 2, 3, 12]

# 40..python运行程序的两种方式 if __name__ == '__main__'
# 第一是直接作为脚本执行，第二是import到其他的python脚本中被调用（模块重用）执行
# 都包含内置的变量__name__,当运行模块被执行的时候，__name__等于文件名（包含了后缀.py）；
# test.py
# print
# "first"
# print
# __name__
# if __name = "__main__"
# print
# "second"
#
# 直接运行: first
# # __main__
# second
# 被导入运行: first
# # test
#
# 如果import到其他模块中，则__name__等于模块名称（不包含后缀.py）
#
# 1).__name__可以清晰地反映一个模块在包中的层次
#
# 2).运行Python程序的两种方式
# python
# xxx.py，直接运行xxx.py文件
# python - m
# xxx.py，把xxx.py当做模块运行


# 42.单元测试框架 unittest
# Pyhon工作原理—— 核心概念：test case, testsuite, TestLoder,TextTestRunner,TextTestResult, test fixture
# TestCase（测试用例）: 所有测试用例的基类，它是软件 测试中最基本的组成单元。
# 一个test case就是一个测试用例，是一个完整的测试流程，包括测试前环境的搭建setUp，执行测试代码(run)，以及测试后环境的还原(tearDown)。测试用例是一个完整的测试单元，可以对某一问题进行验证。
# TestSuite（测试套件）:多个测试用例test case集合就是TestSuite，TestSuite可以嵌套TestSuite
# TestLoder：是用来加载 TestCase到TestSuite中，其中有几个loadTestsFrom_()方法，就是从各个地方寻找TestCase，创建他们的实例，然后add到TestSuite中，再返回一个TestSuite实例
# TextTestRunner：是来执行测试用例的，其中的run（test）会执行TestSuite/TestCase中的run(result)方法。
# TextTestResult：测试结果会保存到TextTestResult实例中，包括运行了多少用例，成功与失败多少等信息
# TestFixture:又叫测试脚手，测试代码的运行环境，指测试准备前和执行后要做的工作，包括setUp和tearDown方法

# 42.pyc 和 pyd文件
# # .pyd文件一般是其他语言编写的python扩展模块
#
# # .pyc
# pyc是a.py中的模块在b.py中导入，生成的一个二进制文件；下次再执行a.py文件，首先会执行这个.pyc文件，如果a.py文件中的内容未更新的话，就直接读取了该.pyc文件；类似一个缓存机制

# 43.PEP8检测工具 pylint
# 1.代码编排
# 2.文档编排
# 3.空格的使用
# 4.注释
# 5.文档描述
# 6.命名规范
# 7.编码建议

# 43.PEP8检测工具 pylint
# 1.代码编排
# 2.文档编排
# 3.空格的使用
# 4.注释
# 5.文档描述
# 6.命名规范
# 7.编码建议
# Pylint 是一个 Python 工具，除了平常代码分析工具的作用之外，它提供了更多的功能：如检查一行代码的长度，变量名是否符合命名标准，一个声明过的接口是否被真正实现等等。
# 安装 pip install pylint
# 为pylint.conf的文件，该文件中的配置项都是pylint的默认配置，比较大400多行
# error 错误
# warning 警告
# refactor
# convention 规范

# 44.文件读写操作
# 使用文件的目的: 数据持久化
# 访问模式:
# r: 只读方式
# w: 写入 文件存在则覆盖,不存在则创建
# a: 追加 存在就追加,不存在就新建
# rb wb ab (b 二进制文件)

# 45.字符串格式化与format的区别
# 最烦人的是%它无法同时传递一个变量和元组
# "hi there %s" % name
# 如果name恰好是(1, 2, 3)，它将会抛出一个TypeError异常
#
# format用法（基本语法是通过{}和:来代替%。format函数可以接受不限个参数，位置可以不按顺序）

# 46.xrange 和range有啥区别
# python3中没有xrange
# range 生成一个序列 列表
# xrange 生成器(要生成很大的数字序列的时候使用,不需要开辟大的内存空间)每次调用返回其中的一个值
# 基本上在循环的时候使用

# 47.timeit模块
# timeit模块可以用来测试一小段Python代码的执行速度
# class timeit.Timer(stmt='pass', setup='pass', timer=<timer function>)
# Timer是测量小段代码执行速度的类。
# stmt参数是要测试的代码语句（statment）；
# setup参数是运行代码时需要的设置；
# timer参数是一个定时器函数，与平台有关。
# timeit.Timer.timeit(number=1000000)
# Timer类中测试语句执行速度的对象方法。number参数是测试代码时的测试次数，默认为1000000次。方法返回执行代码的平均耗时，一个float类型的秒数。

# 48.字典底层原理
# 它的查询复杂度是 O(1)
# # 哈希表(散列表)
# 哈希表（也叫散列表），根据关键值对(Key-value)而直接进行访问的数据结构。它通过把key和value映射到表中一个位置来访问记录，这种查询速度非常快，更新也快。而这个映射函数叫做哈希函数，存放值的数组叫做哈希表。 哈希函数的实现方式决定了哈希表的搜索效率
#  key          value
# 哈希函数       哈希表
# 整数数字   下标的数组空间里     余数结果当做数组的下标
# 1).数据添加：把key通过哈希函数转换成一个整型数字，然后就将该数字对数组长度进行取余，取余结果就当作数组的下标，将value存储在以该数字为下标的数组空间里
# 2).数据查询：再次使用哈希函数将key转换为对应的数组下标，并定位到数组的位置获取value
# 对key进行hash的时候，不同的key可能hash出来的结果是一样的，尤其是数据量增多的时候，这个问题叫做哈希冲突。如果解决这种冲突情况呢？通常的做法有两种，一种是链接法，另一种是开放寻址法，Python选择后者
# # 开放寻址法
# 开放寻址法中，所有的元素都存放在散列表里，当产生哈希冲突时，通过一个探测函数计算出下一个候选位置，如果下一个获选位置还是有冲突，那么不断通过探测函数往下找，直到找个一个空槽来存放待插入元素

# 49.列表字典之间转换
# 使用zip()函数
# 1、现在有两个列表，list1 = ['key1','key2','key3']和list2 = ['1','2','3']，把他们转为这样的字典：{'key1':'1','key2':'2','key3':'3'}
# >>>list1 = ['key1','key2','key3']
# >>>list2 = ['1','2','3']
# >>>dict(zip(list1,list2))
# {'key1':'1','key2':'2','key3':'3'}
# 2. 将嵌套列表转换为字典
# >>>new_list= [['key1','value1'],['key2','value2'],['key3','value3']]
# 
# >>>dict(list)
# 
# {'key3': 'value3', 'key2': 'value2', 'key1': 'value1'}
# 
# 字典转换成列表
# 字典可以直接使用list转换成列表
